<html><head>
        <!-- Generated by Ddoc from sel/entity/entity.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>sel.entity.entity</title>
        </head><body>
        <h1>sel.entity.entity</h1>
<br><br>
<dl><dt><big><a name="Entity"></a>abstract class <u>Entity</u>: <u>sel.event.event.EventListener!(WorldEvent).EventListener</u>;
</big></dt>
<dd>Base abstract class for every entity.<br><br>

<dl><dt><big><a name="Entity.type"></a>pure nothrow @property @safe string <u>type</u>();
</big></dt>
<dd>Gets the entity's <u>type</u> in a string format.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(creeper.<u>type</u> == <font color=red>"creeper"</font>);
<font color=blue>assert</font>(witherSkull.<u>type</u> == <font color=red>"wither_skull"</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Entity.minecraft"></a>pure nothrow @nogc @property @safe bool <u>minecraft</u>();
</big></dt>
<dd>Indicates whether the entity exists in Minecraft.<br><br>

</dd>
<dt><big><a name="Entity.pocket"></a>pure nothrow @nogc @property @safe bool <u>pocket</u>();
</big></dt>
<dd>Indicates whether the entity exists in Minecraft: Pocket Edition.<br><br>

</dd>
<dt><big><a name="Entity.width"></a>pure nothrow @nogc @property @safe double <u>width</u>();
</big></dt>
<dd>Gets the item's <u>width</u>.
<br><br>
<b>Returns:</b><br>
a number higher than 0 or double.nan if the entity has no size<br><br>

</dd>
<dt><big><a name="Entity.height"></a>pure nothrow @nogc @property @safe double <u>height</u>();
</big></dt>
<dd>Gets the item's <u>height</u>.
<br><br>
<b>Returns:</b><br>
a number higher than 0 or double.nan if the entity has no size<br><br>

</dd>
<dt><big><a name="Entity.object"></a>pure nothrow @nogc @property @safe bool <u>object</u>();
</big></dt>
<dd>Indicates whether the entity is an <u>object</u>. If not the entity is
 a mob (living entity).<br><br>

</dd>
<dt><big><a name="Entity.objectData"></a>final pure nothrow @nogc @property @safe int <u>objectData</u>();
</big></dt>
<dd>If the entity is an object gets the object's extra data used
 in Minecraft's SpawnObject packet.<br><br>

</dd>
<dt><big><a name="Entity.uuid"></a>final pure nothrow @nogc @property @safe UUID <u>uuid</u>();
</big></dt>
<dd>Gets the unique identifier (UUID).
 It's usually randomly generated when the entity is
 created and it can only be changed by the child classes.<br><br>

</dd>
<dt><big><a name="Entity.world"></a>pure nothrow @nogc @property @safe World <u>world</u>();
</big></dt>
<dd>Gets the <u>world</u> the entity has been spawned into.
 Non-player entities should always have the same <u>world</u> for
 their whole life-cycle.<br><br>

</dd>
<dt><big><a name="Entity.ticks"></a>final pure nothrow @nogc @property @safe tick_t <u>ticks</u>();
</big></dt>
<dd>Gets the amount of <u>ticks</u> for this entity.
 The <u>ticks</u> doesn't indicates the life-time of the entity, but
 how many times it has been ticked by its world.<br><br>

</dd>
<dt><big><a name="Entity.shouldSee"></a>@safe bool <u>shouldSee</u>(Entity <i>entity</i>);
</big></dt>
<dd>Indicates which entities this one should and should not see.
 By default only the entities indicated as <b>true</b> by this function
 will be shown through the <a href="#Entity.show">show</a> function
 and added to the watchlist.
 For example, an arrow can see a painting, so Arrow.<u>shouldSee</u>(painting)
 will be <b>true</b>, but a painting shouldn't see an arrow, so Painting.<u>shouldSee</u>(arrow)
 will be <b>false</b>.
 This increases the performances as there are less controls, casts and operation
 on arrays in big worlds or chunks of worlds with an high concetration of entities.<br><br>

</dd>
<dt><big><a name="Entity.show"></a>@safe bool <u>show</u>(Entity <i>entity</i>);
</big></dt>
<dd>Adds an <i>entity</i> to the ones this <i>entity</i> can see.
<br><br>
<b>Params:</b><br>
<table><tr><td>Entity <i>entity</i></td>
<td>the <i>entity</i> that will be showed to this <i>entity</i></td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the <i>entity</i> has been added to the visible entities, <b>false</b> otherwise
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>foreach</font>(Player player ; world.players) {
   player.<u>show</u>(<i>entity</i>);
   <i>entity</i>.<u>show</u>(player);
}
</pre>
<br><br>

</dd>
<dt><big><a name="Entity.sees"></a>@nogc @safe bool <u>sees</u>(Entity <i>entity</i>);
</big></dt>
<dd>Checks wether this <i>entity</i> can see or not another <i>entity</i>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(!player.<u>sees</u>(arrow)) {
   player.show(arrow);
}
</pre>
<br><br>

</dd>
<dt><big><a name="Entity.hide"></a>@safe bool <u>hide</u>(Entity <i>entity</i>);
</big></dt>
<dd>Hides an <i>entity</i> from this <i>entity</i>, if this <i>entity</i> can see it.
<br><br>
<b>Params:</b><br>
<table><tr><td>Entity <i>entity</i></td>
<td>the <i>entity</i> to be hidden</td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the <i>entity</i> has been hidden, <b>false</b> otherwise
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>foreach</font>(Living living ; <i>entity</i>.watchlist!Living) {
   <i>entity</i>.<u>hide</u>(living);
   living.<u>hide</u>(<i>entity</i>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="Entity.watchlist"></a>final @property @trusted T[] <u>watchlist</u>(T : Entity = Entity)();
</big></dt>
<dd>Gets a list of the entities that this entity can see.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// every entity
</font><font color=blue>auto</font> entities = entity.<u>watchlist</u>;

<font color=green>// every player
</font><font color=blue>auto</font> players = entity.<u>watchlist</u>!Player;
</pre>
<br><br>

</dd>
<dt><big><a name="Entity.viewers"></a>final @property @trusted T[] <u>viewers</u>(T : Entity = Entity)();
</big></dt>
<dd>Gets a list of the entities that can see this entity.
<br><br>
<b>See Also:</b><br>
watchlist for the examples on the usage<br><br>

</dd>
<dt><big><a name="Entity.despawn"></a>protected void <u>despawn</u>();
</big></dt>
<dd>Despawns this entity, calling the event in the world.<br><br>

</dd>
<dt><big><a name="Entity.alive"></a>@property @safe bool <u>alive</u>();
<br><a name="Entity.dead"></a>@property @safe bool <u>dead</u>();
</big></dt>
<dd>Checks the <u>dead</u>/<u>alive</u> status of the entity.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(entity.<u>alive</u> ^ entity.<u>dead</u>);
</pre>
<br><br>

</dd>
<dt><big><a name="Entity.chunk"></a>final @property @safe ChunkPosition <u>chunk</u>();
</big></dt>
<dd>Gets the 16x16 <u>chunk</u> the entity is in.
 A bigger <u>chunk</u> can be obtained by right-shifting the vector
 by the required amount.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> <u>chunk</u> = entity.<u>chunk</u>;
<font color=blue>auto</font> chunk128 = entity.<u>chunk</u> &gt;&gt; 3;
</pre>
<br><br>

</dd>
<dt><big><a name="Entity.position"></a>pure nothrow @nogc @property @safe EntityPosition <u>position</u>();
</big></dt>
<dd>Gets the entity's <u>position</u>.<br><br>

</dd>
<dt><big><a name="Entity.motion"></a>pure nothrow @nogc @property @safe EntityPosition <u>motion</u>();
</big></dt>
<dd>Gets the entity's <u>motion</u>.<br><br>

</dd>
<dt><big><a name="Entity.motion.2"></a>@property @safe EntityPosition <u>motion</u>(EntityPosition <u>motion</u>);
</big></dt>
<dd>Sets the entity's <u>motion</u>.<br><br>

</dd>
<dt><big><a name="Entity.motionless"></a>@property @safe bool <u>motionless</u>();
</big></dt>
<dd>Checks whether or not an entity has motion.
 A <u>motionless</u> entity has every value of the motion's vector
 equal to 0.<br><br>

</dd>
<dt><big><a name="Entity.motionless.2"></a>@property @safe bool <u>motionless</u>(bool <u>motionless</u>);
</big></dt>
<dd>Sets the entity as <u>motionless</u>.
 This is equivalent to motion = EntityPosition(0).<br><br>

</dd>
<dt><big><a name="Entity.velocity"></a>@property @safe Vector3!short <u>velocity</u>();
</big></dt>
<dd>Gets the motion as pc's <u>velocity</u>, ready to be encoded
 in a packet.
 Due to this encoding limitation, the entity's motion should
 never be higher than 4.096 (2^15 / 8000).
 If it is, it will be clamped.<br><br>

</dd>
<dt><big><a name="Entity.yaw"></a>final pure nothrow @nogc @property @safe float <u>yaw</u>();
</big></dt>
<dd>Gets the entity's looking direction (right-left).
 The value should always be in range 0..360.<br><br>

</dd>
<dt><big><a name="Entity.angleYaw"></a>final @property @safe ubyte <u>angleYaw</u>();
</big></dt>
<dd>Gets the yaw as an unsigned byte for encoding reasons.
 To obtain a valid value the yaw should be in its valid range
 from 0 to 360.<br><br>

</dd>
<dt><big><a name="Entity.pitch"></a>final pure nothrow @nogc @property @safe float <u>pitch</u>();
</big></dt>
<dd>Gets the entity's looking direction (up-down).
 The value should be in range -90..90 (90 included).<br><br>

</dd>
<dt><big><a name="Entity.anglePitch"></a>final @property @safe byte <u>anglePitch</u>();
</big></dt>
<dd>Gets the pitch as a byte for encoding reasons.
 To btain a valid value the pitch should be in its valid range
 from -90 to 90.<br><br>

</dd>
<dt><big><a name="Entity.onGround"></a>final pure nothrow @nogc @property @safe bool <u>onGround</u>();
</big></dt>
<dd>Boolean value indicating whether or not the player is touching
 the ground or is in it.
 This value is <b>true</b> even if the player is in a liquid (like water).<br><br>

</dd>
<dt><big><a name="Entity.direction"></a>final @property @safe EntityPosition <u>direction</u>();
</big></dt>
<dd>Gets the player's looking <u>direction</u> calculated from yaw and pitch.
 The return value is in range 0..1 and it should be multiplied to
 obtain the desired value.<br><br>

</dd>
<dt><big><a name="Entity.move"></a>@safe void <u>move</u>(EntityPosition <i>position</i>, float <i>yaw</i> = Rotation.KEEP, float <i>pitch</i> = Rotation.KEEP);
</big></dt>
<dd>Moves the entity.<br><br>

</dd>
<dt><big><a name="Entity.teleport"></a>@trusted void <u>teleport</u>(EntityPosition <i>position</i>, float <i>yaw</i> = Rotation.KEEP, float <i>pitch</i> = Rotation.KEEP);
<br>void <u>teleport</u>(BlockPosition <i>position</i>, float <i>yaw</i> = Rotation.KEEP, float <i>pitch</i> = Rotation.KEEP);
<br>void <u>teleport</u>(Position <i>position</i>, float <i>yaw</i> = Rotation.KEEP, float <i>pitch</i> = Rotation.KEEP);
</big></dt>
<dd>Teleports the entity.<br><br>

</dd>
<dt><big><a name="Entity.eyeHeight"></a>final pure nothrow @nogc @property @safe double <u>eyeHeight</u>();
</big></dt>
<dd>Gets entity's sizes.<br><br>

</dd>
<dt><big><a name="Entity.updateGroundStatus"></a>protected void <u>updateGroundStatus</u>();
</big></dt>
<dd>Does the onGround updates.<br><br>

</dd>
<dt><big><a name="Entity.falling"></a>final pure nothrow @nogc @property @safe bool <u>falling</u>();
</big></dt>
<dd>Boolean value indicating whether or not the entity
 is <u>falling</u>.<br><br>

</dd>
<dt><big><a name="Entity.doPhysic"></a>protected @safe void <u>doPhysic</u>();
</big></dt>
<dd>Does physic movements using the entity's parameters.<br><br>

</dd>
<dt><big><a name="Entity.checkCollisionsWithEntities"></a>protected void <u>checkCollisionsWithEntities</u>();
</big></dt>
<dd>Checks collisions with the entities in the watchlist
 and calls onCollideWithEntity on collision.<br><br>

</dd>
<dt><big><a name="Entity.onCollideWithEntity"></a>protected bool <u>onCollideWithEntity</u>(Entity <i>entity</i>);
</big></dt>
<dd>Function called from checkCollisionWithEntities when
 this <i>entity</i> collides with another <i>entity</i>.
<br><br>
<b>Returns:</b><br>
<b>false</b> if the calling function should check for more collisions, <b>true</b> otherwise.<br><br>

</dd>
<dt><big><a name="Entity.setSize"></a>@safe void <u>setSize</u>(float <i>width</i>, float <i>height</i>);
</big></dt>
<dd>Updates the size of the entity and its bounding box.<br><br>

</dd>
<dt><big><a name="Entity.box"></a>final @nogc @property @safe EntityAxis <u>box</u>();
</big></dt>
<dd>Gets the entity's bounding <u>box</u>.<br><br>

</dd>
<dt><big><a name="Entity.scale"></a>final pure nothrow @nogc @property @safe float <u>scale</u>();
</big></dt>
<dd>/**
	 * Gets the entity's width.
	 */
	public final @property @safe @nogc float width() {
		return this.box.width;
	}
<br><br>
/**
	 * Gets the entity's height.
	 */
	public final @property @safe @nogc float height() {
		return this.box.height;
	}<br><br>

</dd>
<dt><big><a name="Entity.vehicle"></a>@nogc @property @safe Entity <u>vehicle</u>();
</big></dt>
<dd>Gets the entity's vechicle.<br><br>

</dd>
<dt><big><a name="Entity.vehicle.2"></a>protected @property @safe Entity <u>vehicle</u>(Entity <u>vehicle</u>);
</big></dt>
<dd>Sets the entity's <u>vehicle</u>.<br><br>

</dd>
<dt><big><a name="Entity.passenger"></a>@property @safe Entity <u>passenger</u>();
</big></dt>
<dd>Gets the entity's <u>passenger</u>.<br><br>

</dd>
<dt><big><a name="Entity.passenger.2"></a>@property Entity <u>passenger</u>(Entity <u>passenger</u>);
</big></dt>
<dd>Sets the entity's <u>passenger</u>.
 The vehicle of the <u>passenger</u> is set automatically.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Player player = <font color=red>"steve"</font>.player;
Boat boat = world.spawn!Boat;

boat.<u>passenger</u> = player;
<font color=blue>assert</font>(player.vehicle == boat);
</pre>
<br><br>

</dd>
<dt><big><a name="Entity.attack"></a>T <u>attack</u>(T : EntityDamageEvent)(T <i>event</i>) if (is(T == class) &amp;&amp; !isAbstractClass!T);
</big></dt>
<dd>Attacks an entity and returns the <i>event</i> used.<br><br>

</dd>
<dt><big><a name="Entity.broadcastMetadata"></a>protected void <u>broadcastMetadata</u>();
</big></dt>
<dd>Send the metadata to the viewers<br><br>

</dd>
<dt><big><a name="Entity.drop"></a>void <u>drop</u>(Slot <i>slot</i>);
</big></dt>
<dd>Drop an item from this entity<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="VariableChanged"></a>class <u>VariableChanged</u>(T : Entity, string changes): T;
</big></dt>
<dd>A template for entities with changes on variables.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// an entity on fire by default
</font><font color=blue>alias</font> OnFire(T) = Changed!(T, <font color=red>"this.onFire = true;"</font>);
Creeper creeper = world.spawn!(OnFire!Creeper);
<font color=blue>assert</font>(creeper.onFire);

<font color=green>// multiple changes can be used togheter
</font><font color=blue>new</font> OnFire!(Unticked!(Noai!Creeper))();
</pre>
<br><br>

</dd>
<dt><big><a name="Unticked"></a>template <u>Unticked</u>(T : Entity)</big></dt>
<dd>An entity without ticking.<br><br>

</dd>
<dt><big><a name="Noai"></a>template <u>Noai</u>(T : Entity)</big></dt>
<dd>An Entity without AI.<br><br>

</dd>
<dt><big><a name="UntickedNoai"></a>template <u>UntickedNoai</u>(T : Entity)</big></dt>
<dd>An entity without ticking and AI.<br><br>

</dd>
<dt><big><a name="FunctionChanged"></a>class <u>FunctionChanged</u>(T : Entity, string changes): T;
</big></dt>
<dd>A template for entities with changing on functions.<br><br>

</dd>
<dt><big><a name="NoPhysic"></a>template <u>NoPhysic</u>(T : Entity)</big></dt>
<dd>An entity without physic.<br><br>

</dd>
<dt><big><a name="NoFallDamage"></a>template <u>NoFallDamage</u>(T : Entity)</big></dt>
<dd>An entity that doesn't take fall damage.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
