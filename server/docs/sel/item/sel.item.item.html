<html><head>
        <!-- Generated by Ddoc from sel/item/item.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>sel.item.item</title>
        </head><body>
        <h1>sel.item.item</h1>
<br><br>
<dl><dt><big><a name="Item"></a>class <u>Item</u>;
</big></dt>
<dd>Base class for an <u>Item</u>.<br><br>

<dl><dt><big><a name="Item.this"></a>@trusted this(string <i>data</i>);
</big></dt>
<dd>Constructs an item with some extra <i>data</i>.
<br><br>
<b>Throws:</b><br>
JSONException if the JSON string is malformed
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> item = <font color=blue>new</font> Items.Apple(<font color=red>`{"customName":"SPECIAL APPLE","enchantments":[{"name":"protection","level":"IV"}]}`</font>);
<font color=blue>assert</font>(item.customName == <font color=red>"SPECIAL APPLE"</font>);
<font color=blue>assert</font>(Enchantments.protection <font color=blue>in</font> item);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.this.2"></a>@safe this(std.json.JSONValue <i>data</i>);
</big></dt>
<dd>Constructs an item adding properties from a JSON.
<br><br>
<b>Throws:</b><br>
RangeError if the enchanting name doesn't exist<br><br>

</dd>
<dt><big><a name="Item.data"></a>const pure nothrow @nogc @property @safe sul.items.Item <u>data</u>();
</big></dt>
<dd>Gets the item's <u>data</u>.<br><br>

</dd>
<dt><big><a name="Item.minecraft"></a>pure nothrow @nogc @property @safe bool <u>minecraft</u>();
<br><a name="Item.minecraftId"></a>pure nothrow @nogc @property @safe ushort <u>minecraftId</u>();
<br><a name="Item.minecraftMeta"></a>pure nothrow @nogc @property @safe ushort <u>minecraftMeta</u>();
</big></dt>
<dd>Indicates wether the item exists in Minecraft.<br><br>

</dd>
<dt><big><a name="Item.pocket"></a>pure nothrow @nogc @property @safe bool <u>pocket</u>();
</big></dt>
<dd>Indicates whether the item exists in Minecraft: Pocket Edition.<br><br>

</dd>
<dt><big><a name="Item.name"></a>pure nothrow @nogc @property @safe string <u>name</u>();
</big></dt>
<dd>Gets the <u>name</u> (not the custom <u>name</u>!) of the item.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(item.<u>name</u> == <font color=red>"string"</font>)
   item.customName = <font color=red>"Special String"</font>;
</pre>
<br><br>

</dd>
<dt><big><a name="Item.max"></a>pure nothrow @nogc @property @safe ubyte <u>max</u>();
</big></dt>
<dd>Indicates the highest number of items that can be stacked in a slot.
 This number is the default slot's count if not specified when created.
<br><br>
<b>Returns:</b><br>
a number between 1 and 64 (usually 1, 16 or 64).
<br><br>
<b>Example:</b><br>
<pre class="d_code">Slot slot = <font color=blue>new</font> Items.Beetroot();
<font color=blue>assert</font>(slot.count == 64 &amp;&amp; slot.item.<u>max</u> == 64);
<font color=blue>assert</font>(slot.item.<u>max</u> == 64);

slot = <font color=blue>new</font> Slot(<font color=blue>new</font> Items.Beetroot(), 23);
<font color=blue>assert</font>(slot.count != 64 &amp;&amp; slot.count == 23);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.tool"></a>pure nothrow @nogc @property @safe bool <u>tool</u>();
</big></dt>
<dd>Indicates whether the item is a <u>tool</u>.
 A <u>tool</u> can be used on blocks and entities
 and its meta will vary.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<font color=blue>new</font> Items.Beetroot().<u>tool</u> == <font color=blue>false</font>);
<font color=blue>assert</font>(<font color=blue>new</font> Items.DiamondSword().<u>tool</u> == <font color=blue>true</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.toolType"></a>pure nothrow @nogc @property @safe ubyte <u>toolType</u>();
</big></dt>
<dd>Gets the item's tool type.
<br><br>
<b>Returns:</b><br>
Tools.none if the item is not a tool or a number higher
 			than 0 indicating the tool type.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<font color=blue>new</font> Items.Beetroot().<u>toolType</u> == Tools.none);
<font color=blue>assert</font>(<font color=blue>new</font> Items.DiamondSword().<u>toolType</u> == Tools.sword);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.toolMaterial"></a>pure nothrow @nogc @property @safe ubyte <u>toolMaterial</u>();
</big></dt>
<dd>Gets the tool's material if the item is a tool.
 Items with ID 0 have unspecified material, 1 is the minimum (wood)
 and 5 is the maximum (diamond).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<font color=blue>new</font> Items.Beetroot().<u>toolMaterial</u> == NO_TOOL);
<font color=blue>assert</font>(<font color=blue>new</font> Items.DiamondSword().<u>toolMaterial</u> == DIAMOND);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.finished"></a>pure nothrow @nogc @property @safe bool <u>finished</u>();
</big></dt>
<dd>If the item is a tool, checks whether its damage is higher than
 its durability.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<font color=blue>new</font> Items.Beetroot().<u>finished</u> == <font color=blue>false</font>); <font color=green>// beetroots aren't tools
</font><font color=blue>assert</font>(<font color=blue>new</font> Items.DiamondSword().<u>finished</u> == <font color=blue>false</font>);
<font color=blue>assert</font>(<font color=blue>new</font> Items.DiamondSword(Items.DiamondSword.DURABILITY + 1).<u>finished</u> == <font color=blue>true</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.attack"></a>pure nothrow @nogc @property @safe uint <u>attack</u>();
</big></dt>
<dd>Indicates the damage caused by the item when used as a weapon.
 The value indicates the base damage without the influence of
 enchantments or effects.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(item.<u>attack</u> &gt; 1)
   <font color=blue>assert</font>(item.tool);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.consumeable"></a>pure nothrow @nogc @property @safe bool <u>consumeable</u>();
</big></dt>
<dd>Indicates whether or not an item can be eaten/drunk.
 If <b>true</b>, Item::onConsumed(Human consumer) will be called
 when this item is eaten/drunk.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(item.<u>consumeable</u>) {
   Item residue;
   <font color=blue>if</font>((residue = item.onConsumed(player)) !<font color=blue>is</font> <font color=blue>null</font>) {
      player.held = residue;
   }
}
</pre>
<br><br>

</dd>
<dt><big><a name="Item.alwaysConsumeable"></a>pure nothrow @nogc @property @safe bool <u>alwaysConsumeable</u>();
</big></dt>
<dd>Indicates whether the item can be consumed when the holder's
 hunger is full.<br><br>

</dd>
<dt><big><a name="Item.onConsumed"></a>Item <u>onConsumed</u>(Player <i>player</i>);
</big></dt>
<dd>If consumeable is <b>true</b>, this function is called.
 when the item is eaten/drunk by its holder, who's passed
 as the first arguments.
<br><br>
<b>Return:</b><br>
<br><br>
<b>null:</b><br>
the item count will be reduced by 1
<br><br>
<b>item:</b><br>
the item will substitutes the consumed item
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<font color=blue>new</font> Items.Beetroot().<u>onConsumed</u>(<i>player</i>) <font color=blue>is</font> <font color=blue>null</font>);
<font color=blue>assert</font>(<font color=blue>new</font> Items.BeetrootSoup().<u>onConsumed</u>(<i>player</i>) == Items.BOWL);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.placeable"></a>pure nothrow @nogc @property @safe bool <u>placeable</u>();
</big></dt>
<dd>Indicates whether or not the item can be placed.
 If this function returns <b>true</b>, Item::place(World world) will be probably
 called next for place a block<br><br>

</dd>
<dt><big><a name="Item.onPlaced"></a>bool <u>onPlaced</u>(Player <i>player</i>, BlockPosition <i>tpos</i>, uint <i>tface</i>);
</big></dt>
<dd>Function called when the item is ready to be placed by
 a <i>player</i> (the event for the <i>player</i> has already been called).
<br><br>
<b>Returns:</b><br>
<b>true</b> if a block has been placed, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Item.place"></a>ushort <u>place</u>(World <i>world</i>, BlockPosition <i>position</i>, uint <i>face</i>);
</big></dt>
<dd>If Item::placeable returns <b>true</b>, this function
 should return an instance of the block that will
 be placed.
<br><br>
<b>Params:</b><br>
<table><tr><td>World <i>world</i></td>
<td>the <i>world</i> where the block has been placed</td></tr>
<tr><td>BlockPosition <i>position</i></td>
<td>where the item should <u>place</u> the block</td></tr>
<tr><td>uint <i>face</i></td>
<td>side of the block touched when placed</td></tr>
</table><br>

</dd>
<dt><big><a name="Item.useOnBlock"></a>bool <u>useOnBlock</u>(Player <i>player</i>, Block <i>block</i>, BlockPosition <i>position</i>, ubyte <i>face</i>);
</big></dt>
<dd>Function called when the item is used on a <i>block</i>
 clicking the right mouse button or performing a long pressure on the screen.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the item is a tool and it has been cosnumed, <b>false</b> otherwise
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// N.B. that this will not work as the block hasn't been placed
</font>world[0, 64, 0] = Blocks.DIRT;
<font color=blue>assert</font>(world[0, 64, 0] == Blocks.DIRT);

<font color=blue>new</font> Items.WoodenShovel().<u>useOnBlock</u>(<i>player</i>, world[0, 64, 0], Faces.TOP);

<font color=blue>assert</font>(world[0, 64, 0] == Blocks.GRASS_PATH);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.destroyOn"></a>bool <u>destroyOn</u>(Player <i>player</i>, Block <i>block</i>, BlockPosition <i>position</i>);
</big></dt>
<dd>Function called when the item is used to the destroy a <i>block</i>.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the item is a tool and it has been consumed, <b>false</b> otherwise
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> dirt = <font color=blue>new</font> Blocks.Dirt();
<font color=blue>auto</font> sword = <font color=blue>new</font> Items.DiamondSword(Items.DiamondSword.DURABILITY - 2);
<font color=blue>auto</font> shovel = <font color=blue>new</font> Items.DiamondShovel(Items.DiamondShovel.DURABILITY - 2);

<font color=blue>assert</font>(sword.finished == <font color=blue>false</font>);
<font color=blue>assert</font>(shovel.finished == <font color=blue>false</font>);

sword.<u>destroyOn</u>(<i>player</i>, dirt);	<font color=green>// 2 uses
</font>shovel.<u>destroyOn</u>(<i>player</i>, dirt);	<font color=green>// 1 use
</font>
<font color=blue>assert</font>(sword.finished == <font color=blue>true</font>);
<font color=blue>assert</font>(shovel.finished == <font color=blue>false</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.useOnEntity"></a>bool <u>useOnEntity</u>(Player <i>player</i>, Entity <i>entity</i>);
</big></dt>
<dd>Function called when the item is used on an <i>entity</i> as
 right click or long screen pressure.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the items is a tool and it has been consumed, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Item.attackOnEntity"></a>bool <u>attackOnEntity</u>(Player <i>player</i>, Entity <i>entity</i>);
</big></dt>
<dd>Function called when the item is used against an
 <i>entity</i> as a left click or screen tap.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the items is a tool and it has been consumed, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Item.onThrowed"></a>bool <u>onThrowed</u>(Player <i>player</i>);
</big></dt>
<dd>Function called when the item is throwed or aimed.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the item count should be reduced by 1, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Item.onReleased"></a>bool <u>onReleased</u>(Player <i>holder</i>);
</big></dt>
<dd>Function called when the item is released, usually after
 it has been throwed (which is used as aim-start function).
<br><br>
<b>Returns:</b><br>
<b>true</b> if the item has been consumed, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Item.minecraftCompound"></a>final pure nothrow @nogc @property @safe Compound <u>minecraftCompound</u>();
<br><a name="Item.pocketCompound"></a>final pure nothrow @nogc @property @safe Compound <u>pocketCompound</u>();
</big></dt>
<dd>Gets the item's compound tag with the custom data of the item.
 It may be <b>null</b> if the item has no custom behaviours.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(item.<u>minecraftCompound</u> <font color=blue>is</font> <font color=blue>null</font>) {
   <font color=blue>assert</font>(item.customName == <font color=red>""</font>);
}
item.customName = <font color=red>"not empty"</font>;
<font color=blue>assert</font>(item.<u>pocketCompound</u> !<font color=blue>is</font> <font color=blue>null</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.parseMinecraftCompound"></a>@safe void <u>parseMinecraftCompound</u>(Compound <i>compound</i>);
<br><a name="Item.parsePocketCompound"></a>@safe void <u>parsePocketCompound</u>(Compound <i>compound</i>);
</big></dt>
<dd>Parses a <i>compound</i>, usually received from the client or
 saved in a world.
 The tag should never be <b>null</b> as the method doesn't check it.
<br><br>
<b>Example:</b><br>
<pre class="d_code">item.<u>parseMinecraftCompound</u>(<font color=blue>new</font> Compound(<font color=blue>new</font> Compound(<font color=red>"display"</font>, <font color=blue>new</font> String(<font color=red>"Name"</font>, <font color=red>"custom"</font>))));
<font color=blue>assert</font>(item.customName == <font color=red>"custom"</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.clear"></a>@trusted void <u>clear</u>();
</big></dt>
<dd>Removes the custom behaviours of the item, like custom name
 and enchantments.
<br><br>
<b>Example:</b><br>
<pre class="d_code">item.customName = <font color=red>"name"</font>;
<font color=blue>assert</font>(item.customName == <font color=red>"name"</font>);
item.<u>clear</u>();
<font color=blue>assert</font>(item.customName == <font color=red>""</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.customName"></a>pure nothrow @nogc @property @safe string <u>customName</u>();
</big></dt>
<dd>Gets the item's custom name.<br><br>

</dd>
<dt><big><a name="Item.customName.2"></a>@property @safe string <u>customName</u>(string <i>name</i>);
</big></dt>
<dd>Sets the item's custom <i>name</i>.
<br><br>
<b>Example:</b><br>
<pre class="d_code">item.<u>customName</u> = <font color=red>"§aColoured!"</font>;
item.<u>customName</u> = <font color=red>""</font>; <font color=green>// remove
</font></pre>
<br><br>

</dd>
<dt><big><a name="Item.lore"></a>pure nothrow @nogc @property @safe string <u>lore</u>();
</big></dt>
<dd>Gets the item's <u>lore</u> or description which is displayed under
 the item's name when the item is hovered in the player's inventory.<br><br>

</dd>
<dt><big><a name="Item.addEnchantment"></a>@safe void <u>addEnchantment</u>(Enchantment <i>ench</i>);
<br>@safe void <u>addEnchantment</u>(sul.enchantments.Enchantment <i>ench</i>, ubyte <i>level</i>);
<br>@safe void <u>addEnchantment</u>(sul.enchantments.Enchantment <i>ench</i>, string <i>level</i>);
<br><a name="Item.opBinaryRight"></a>@safe void <u>opBinaryRight</u>(string op : "+")(Enchantment <i>ench</i>);
<br><a name="Item.enchant"></a>alias <u>enchant</u> = addEnchantment;
</big></dt>
<dd>Adds an enchantment to the item.
<br><br>
<b>Throws:</b><br>
EnchantmentException if the enchantment doesn't exist
<br><br>
<b>Example:</b><br>
<pre class="d_code">item.<u>addEnchantment</u>(<font color=blue>new</font> Enchantment(Enchantments.sharpness, 1));
item.<u>addEnchantment</u>(Enchantments.power, 5);
item.<u>addEnchantment</u>(Enchantments.fortune, <font color=red>"X"</font>);
item += <font color=blue>new</font> Enchantment(Enchantments.smite, 2);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.opBinaryRight.2"></a>@safe Enchantment* <u>opBinaryRight</u>(string op : "in")(sul.enchantments.Enchantment <i>ench</i>);
</big></dt>
<dd>Gets a pointer to the enchantment.
 This method can be used to check if the item has an
 enchantment and its level.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> e = Enchantments.protection <font color=blue>in</font> item;
<font color=blue>if</font>(!e || e.level != 5) {
   item.enchant(Enchantment.protection, 5);
}
<font color=blue>assert</font>(Enchantments.protection <font color=blue>in</font> item);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.removeEnchantment"></a>@safe void <u>removeEnchantment</u>(sul.enchantments.Enchantment <i>ench</i>);
<br><a name="Item.opBinaryRight.3"></a>@safe void <u>opBinaryRight</u>(string op : "-")(sul.enchantments.Enchantment <i>ench</i>);
</big></dt>
<dd>Removes an enchantment from the item.
<br><br>
<b>Example:</b><br>
<pre class="d_code">item.<u>removeEnchantment</u>(Enchantments.sharpness);
item -= Enchantments.fortune;
</pre>
<br><br>

</dd>
<dt><big><a name="Item.unbreakable"></a>pure nothrow @nogc @property @safe bool <u>unbreakable</u>();
</big></dt>
<dd>If the item is a tool, indicates whether the item is consumed
 when used for breaking or combat.<br><br>

</dd>
<dt><big><a name="Item.opEquals"></a>bool <u>opEquals</u>(Object <i>o</i>);
</big></dt>
<dd>Deep comparation of 2 instantiated items.
 Compare ids, metas, custom names and enchantments.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Item a = <font color=blue>new</font> Items.Beetroot();
Item b = a.dup;
<font color=blue>assert</font>(a == b);

a.customName = <font color=red>"beetroot"</font>;
<font color=blue>assert</font>(a != b);

b.customName = <font color=red>"beetroot"</font>;
a.enchant(Enchantments.protection, <font color=red>"IV"</font>);
b.enchant(Enchantments.protection, <font color=red>"IV"</font>);
<font color=blue>assert</font>(a == b);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.opEquals.2"></a>@nogc @safe bool <u>opEquals</u>(item_t <i>item</i>);
<br>@nogc @safe bool <u>opEquals</u>(item_t[] <i>items</i>);
</big></dt>
<dd>Compare an <i>item</i> with its type as a string or a group of strings.
<br><br>
<b>Example:</b><br>
<pre class="d_code">Item <i>item</i> = <font color=blue>new</font> Items.Beetroot();
<font color=blue>assert</font>(<i>item</i> == Items.beetroot);
<font color=blue>assert</font>(<i>item</i> == [Items.beetrootSoup, Items.beetroot]);
</pre>
<br><br>

</dd>
<dt><big><a name="Item.toString"></a>string <u>toString</u>();
</big></dt>
<dd>Returns the item as string in format "name" or "name:damage" for tools.<br><br>

</dd>
<dt><big><a name="Item.slot"></a>final @property @safe Slot <u>slot</u>();
</big></dt>
<dd>Create a <u>slot</u> with the Item::max as count
<br><br>
<b>Example:</b><br>
<pre class="d_code">Slot a = <font color=blue>new</font> Slot(<font color=blue>new</font> Items.Beetroot(), 12);
Slot b = <font color=blue>new</font> Items.Beetroot(); <font color=green>// same as new Items.Beetroot().slot;
</font>
<font color=blue>assert</font>(a.count == 12);
<font color=blue>assert</font>(b.count == 64);
</pre>
<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
