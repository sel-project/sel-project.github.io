<html><head>
        <!-- Generated by Ddoc from sel/session/player.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>sel.session.player</title>
        </head><body>
        <h1>sel.session.player</h1>
<br><br>
<dl><dt><big><a name="PlayerSession"></a>abstract class <u>PlayerSession</u>: <u>sel.network.session.Session</u>;
</big></dt>
<dd>Session for players.<br><br>

<dl><dt><big><a name="PlayerSession.type"></a>abstract shared nothrow @nogc @property @safe ubyte <u>type</u>();
</big></dt>
<dd>Gets the game <u>type</u> as an unsigned byte identifier.
 The types are indicated in module common.sel and will
 likely never change.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(session.<u>type</u> == PE) {
   log(session, <font color=red>" is on Pocket Edition"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="PlayerSession.protocol"></a>final shared nothrow @nogc @property @safe uint <u>protocol</u>();
</big></dt>
<dd>Gets the <u>protocol</u> number used by the client.
 It may be 0 if the packet with the <u>protocol</u> number didn't
 come yet.<br><br>

</dd>
<dt><big><a name="PlayerSession.gameName"></a>final shared nothrow @nogc @property @safe string <u>gameName</u>();
</big></dt>
<dd>Gets the client's game name.
<br><br>
<b>Examples:</b><br>
"Minecraft"
 "Minecraft: Pocket Edition"
 "Minecraft: Gear VR Edition"<br><br>

</dd>
<dt><big><a name="PlayerSession.gameVersion"></a>final shared nothrow @nogc @property @safe string <u>gameVersion</u>();
</big></dt>
<dd>Gets the client's game version, which could either be calculated
 from the protocol number or given by the client.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(player.type == PC)
   <font color=blue>assert</font>(supportedMinecraftProtocols[player.protocol].canFind(player.<u>gameVersion</u>));
</pre>
<br><br>

</dd>
<dt><big><a name="PlayerSession.game"></a>final shared nothrow @property @safe string <u>game</u>();
</big></dt>
<dd>Gets the <u>game</u> type and version as a human-readable string.
<br><br>
<b>Examples:</b><br>
"Minecraft 1.11.0"
 "Minecraft: Pocket Edition 0.16.1"
 "Minecraft: Education Edition 1.0.2"<br><br>

</dd>
<dt><big><a name="PlayerSession.uuid"></a>final shared nothrow @nogc @property @safe UUID <u>uuid</u>();
</big></dt>
<dd>Gets the UUID. It's unique when online-mode is se to <b>true</b>
 and can be used to identify a player.
 When online-mode is set to <b>false</b> it is randomly generated
 and its uses are very limited.<br><br>

</dd>
<dt><big><a name="PlayerSession.suuid"></a>final shared nothrow @property @safe const(suuid_t) <u>suuid</u>();
</big></dt>
<dd>Gets the SEL UUID, a unique identifier for the player in
 the session. It's composed by 17 bytes (type and UUID)
 and it will never change for authenticated players.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(session.type == session.<u>suuid</u>[0]);
</pre>
<br><br>

</dd>
<dt><big><a name="PlayerSession.username"></a>final shared nothrow @nogc @property @safe string <u>username</u>();
</big></dt>
<dd>Gets the player's <u>username</u>, mantaining the case given
 by the login packet.
 It doesn't change during the life of the session.<br><br>

</dd>
<dt><big><a name="PlayerSession.iusername"></a>final shared @property @safe string <u>iusername</u>();
</big></dt>
<dd>Gets the player's lowercase username.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(session.username.toLower == session.<u>iusername</u>);
</pre>
<br><br>

</dd>
<dt><big><a name="PlayerSession.displayName"></a>final shared nothrow @nogc @property @safe string <u>displayName</u>();
</big></dt>
<dd>Gets and sets the player's display name.
 It can contain formatting codes and it could change during
 the session's lifetime (if modified by a node).
 It's usually displayed in the nametag and in the players list.<br><br>

</dd>
<dt><big><a name="PlayerSession.gamemode"></a>final shared nothrow @nogc @property @safe ubyte <u>gamemode</u>();
</big></dt>
<dd>Gets the player's <u>gamemode</u> that may differ from the world's.<br><br>

</dd>
<dt><big><a name="PlayerSession.world"></a>final shared nothrow @nogc @property @safe shared(World) <u>world</u>();
<br><a name="PlayerSession.dimension"></a>final shared nothrow @nogc @property @safe byte <u>dimension</u>();
</big></dt>
<dd>Gets the player's <u>world</u>, which is updated by the node every
 time the client changes <u>dimension</u>.<br><br>

</dd>
<dt><big><a name="PlayerSession.address"></a>final shared nothrow @nogc @property @trusted Address <u>address</u>();
</big></dt>
<dd>Gets the player's remote <u>address</u>. it's usually an ipv4, ipv6
 or an ipv4-mapped ipv6.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(session.<u>address</u>.addressFamily == AddressFamily.INET6) {
   log(session, <font color=red>" is connected through IPv6"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="PlayerSession.serverAddress"></a>final shared nothrow @nogc @property @safe string <u>serverAddress</u>();
</big></dt>
<dd>Address used by the client to connect to the server.
 It's a string and can either be a numerical ip or a full url.<br><br>

</dd>
<dt><big><a name="PlayerSession.serverPort"></a>final shared nothrow @nogc @property @safe ushort <u>serverPort</u>();
</big></dt>
<dd>Port used by the client to connect to the server.<br><br>

</dd>
<dt><big><a name="PlayerSession.latency"></a>abstract shared nothrow @nogc @property @safe uint <u>latency</u>();
</big></dt>
<dd>Gets the player's <u>latency</u>.
 Not being calculated using an ICMP protocol the value may not be
 completely accurate.<br><br>

</dd>
<dt><big><a name="PlayerSession.packetLoss"></a>shared nothrow @nogc @property @safe float <u>packetLoss</u>();
</big></dt>
<dd>Gets the player's latency.
 It returns a floating point value between 0 and 100 where
 0 is no packet loss and 100 is every packet lost since the
 last check.
 If the client uses a stream-oriented connection the value
 will always be 0.<br><br>

</dd>
<dt><big><a name="PlayerSession.language"></a>final shared nothrow @nogc @property @safe string <u>language</u>();
</big></dt>
<dd>Gets/sets the player's <u>language</u>, indicated as code_COUNTRY.<br><br>

</dd>
<dt><big><a name="PlayerSession.skin"></a>final shared nothrow @nogc @property @trusted Skin <u>skin</u>();
</big></dt>
<dd>Gets the player's <u>skin</u> as a Skin object.
 If the player has no <u>skin</u> the object will be <b>null</b>.<br><br>

</dd>
<dt><big><a name="PlayerSession.inputMode"></a>final shared nothrow @nogc @property @safe ubyte <u>inputMode</u>();
</big></dt>
<dd>Gets the player's input mode, ore whether it is using keyboard
 and mouse, a controller or touchscreen.<br><br>

</dd>
<dt><big><a name="PlayerSession.connect"></a>shared bool <u>connect</u>(ubyte <i>reason</i>, int <i>nodeId</i> = -1, ubyte <i>onFail</i> = HncomPlayer.Transfer.DISCONNECT);
</big></dt>
<dd>Tries to <u>connect</u> the player to a node.
 This function does not notify the old node of the change,
 as the old node should have called the function.<br><br>

</dd>
<dt><big><a name="PlayerSession.firstConnect"></a>protected shared void <u>firstConnect</u>();
</big></dt>
<dd>Calls the connect function using 'first join' as reason
 and, if it successfully connects to a node, add the player
 to the server.<br><br>

</dd>
<dt><big><a name="PlayerSession.transfer"></a>shared void <u>transfer</u>(uint <i>node</i>);
</big></dt>
<dd>Function called when the player is manually
 transferred by the hub to a <i>node</i>.<br><br>

</dd>
<dt><big><a name="PlayerSession.sendLatency"></a>protected shared void <u>sendLatency</u>();
</big></dt>
<dd>Sends the latency to the connected node.<br><br>

</dd>
<dt><big><a name="PlayerSession.sendPacketLoss"></a>protected shared void <u>sendPacketLoss</u>();
</big></dt>
<dd>Sends the packet loss to the connected node.<br><br>

</dd>
<dt><big><a name="PlayerSession.sendOrderedFromNode"></a>final shared void <u>sendOrderedFromNode</u>(uint <i>order</i>, ubyte[] <i>payload</i>);
</big></dt>
<dd>Sends a packet from the node and mantain the <i>order</i>.<br><br>

</dd>
<dt><big><a name="PlayerSession.sendFromNode"></a>abstract shared void <u>sendFromNode</u>(ubyte[] <i>payload</i>);
</big></dt>
<dd>Sends an encoded packet to client that has been created
 and encoded by the node.<br><br>

</dd>
<dt><big><a name="PlayerSession.endOfStream"></a>protected abstract shared void <u>endOfStream</u>();
</big></dt>
<dd>Function called when the player tries to connect to
 a node that doesn't exist, either because the name is
 wrong or because there aren't available ones.<br><br>

</dd>
<dt><big><a name="PlayerSession.kick"></a>abstract shared void <u>kick</u>(string <i>reason</i>, bool <i>translation</i>, string[] <i>params</i>);
</big></dt>
<dd>Function called when the player is kicked (by the
 hub or the node).
 The function should send a disconnection message
 and close the session.<br><br>

</dd>
<dt><big><a name="PlayerSession.onTimedOut"></a>protected shared void <u>onTimedOut</u>();
</big></dt>
<dd>Function called when the client times out.<br><br>

</dd>
<dt><big><a name="PlayerSession.onClosedByClient"></a>protected shared void <u>onClosedByClient</u>();
</big></dt>
<dd>Function called when the connection is manually closed
 by the client clicking the disconnect button on the
 game's interface.<br><br>

</dd>
<dt><big><a name="PlayerSession.onKicked"></a>shared void <u>onKicked</u>(string <i>reason</i>);
</big></dt>
<dd>Function called when the client is kicked from
 the hub (not from the node).<br><br>

</dd>
<dt><big><a name="PlayerSession.close"></a>protected shared void <u>close</u>();
</big></dt>
<dd>Closes every connection with the client and
 removes the session from the handler and the
 server (if registered to it).<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
