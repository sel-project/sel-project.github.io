<html><head>
        <!-- Generated by Ddoc from sel/player/player.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>sel.player.player</title>
        </head><body>
        <h1>sel.player.player</h1>
<br><br>
<dl><dt><big><a name="Player"></a>abstract class <u>Player</u>: <u>sel.entity.human.Human</u>, <u>sel.command.util.WorldCommandSender</u>;
</big></dt>
<dd>Abstract class with abstract packet-related functions.
 It's implemented as another class by every version of Minecraft.<br><br>

<dl><dt><big><a name="Player.address"></a>final pure nothrow @nogc @property @safe Address <u>address</u>();
<br><a name="Player.ip"></a>final const pure nothrow @nogc @property @safe string <u>ip</u>();
<br><a name="Player.port"></a>final const pure nothrow @nogc @property @safe ushort <u>port</u>();
</big></dt>
<dd>Gets the player's connection informations.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(player.<u>address</u>.toAddrString() == player.<u>ip</u>);
<font color=blue>assert</font>(player.<u>address</u>.toPortString() == player.<u>port</u>.to!string);

@event login(PlayerLoginEvent event) {
   d(event.player.name, <font color=red>" joined "</font>, event.world.name, <font color=red>" with address "</font>, event.player.<u>address</u>);
   <font color=green>// Steve joined world with address 127.0.0.1:19132
</font>}
</pre>
<br><br>

</dd>
<dt><big><a name="Player.usedIp"></a>final const pure nothrow @nogc @property @safe string <u>usedIp</u>();
<br><a name="Player.usedPort"></a>final const pure nothrow @nogc @property @safe ushort <u>usedPort</u>();
</big></dt>
<dd>Gets the ip and the port the player has used to join the server.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(player.<u>usedIp</u> != <font color=red>"example.com"</font>) {
   player.sendMessage(<font color=red>"Hey! Use the right ip: example.com"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="Player.name"></a>final pure nothrow @nogc @property @safe string <u>name</u>();
</big></dt>
<dd>Gets the player's raw <u>name</u> conserving the
 original upper-lowercase format.<br><br>

</dd>
<dt><big><a name="Player.iname"></a>final pure nothrow @nogc @property @safe string <u>iname</u>();
<br><a name="Player.lname"></a>alias <u>lname</u> = iname;
</big></dt>
<dd>Gets the player's username converted to lower-case.<br><br>

</dd>
<dt><big><a name="Player.displayName"></a>final pure nothrow @nogc @property @safe string <u>displayName</u>();
<br>final @property @trusted string <u>displayName</u>(string <u>displayName</u>);
</big></dt>
<dd>Edits the player's displayed name, as it appears in the
 server's players list (it can be coloured).
 It can be edited on PlayerPreLoginEvent.<br><br>

</dd>
<dt><big><a name="Player.gameVersion"></a>pure nothrow @nogc @property @safe ubyte <u>gameVersion</u>();
</big></dt>
<dd>Gets informations about the player's platform.
<br><br>
<b>See Also:</b><br>
sel.settings.Version
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(player.<u>gameVersion</u> == PE) { ... }
<font color=green>// same as
</font><font color=blue>if</font>(player.pe) { ... }
</pre>
<br><br>

</dd>
<dt><big><a name="Player.protocol"></a>abstract pure nothrow @nogc @property @safe uint <u>protocol</u>();
</big></dt>
<dd>Gets the player's game <u>protocol</u>.<br><br>

</dd>
<dt><big><a name="Player.online"></a>nothrow @nogc @property @safe bool <u>online</u>();
</big></dt>
<dd>Indicates whether or not the player is still connected to
 the node.<br><br>

</dd>
<dt><big><a name="Player.uptime"></a>final @property @safe Duration <u>uptime</u>();
</big></dt>
<dd>Gets the player's connection time as a Duration.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(<font color=red>"steve"</font>.online &amp;&amp; <font color=red>"steve"</font>.player.<u>uptime</u>.hours &gt;= 3) {
   server.kick(<font color=red>"steve"</font>, <font color=red>"your time here has expired!"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="Player.lang"></a>pure nothrow @nogc @property @safe string <u>lang</u>();
</big></dt>
<dd>Gets the language of the player.
 The string will be in the Settings.ACCEPTED_LANGUAGES array,
 as indicated in the hub's configuration file.<br><br>

</dd>
<dt><big><a name="Player.lang.2"></a>@property @trusted string <u>lang</u>(string <u>lang</u>);
</big></dt>
<dd>Sets the language of the player, call the events and resend
 the translatable content.<br><br>

</dd>
<dt><big><a name="Player.inputMode"></a>final pure nothrow @nogc @property @safe InputMode <u>inputMode</u>();
</big></dt>
<dd>Gets the player's input mode.<br><br>

</dd>
<dt><big><a name="Player.latency"></a>final pure nothrow @nogc @property @safe uint <u>latency</u>();
<br><a name="Player.ping"></a>alias <u>ping</u> = latency;
</big></dt>
<dd>Gets the player's <u>latency</u> (in milliseconds), calculated adding the <u>latency</u> from
 the client to the hub and the <u>latency</u> from the hub and the current node.
 For pocket edition players it's calculated through an UDP protocol
 and may not be accurate.<br><br>

</dd>
<dt><big><a name="Player.packetLoss"></a>final pure nothrow @nogc @property @safe float <u>packetLoss</u>();
</big></dt>
<dd>Gets the player's packet loss, if the client is connected through and UDP
 protocol.
<br><br>
<b>Returns:</b><br>
a value between 0 and 100, where 0 means no packet lost and 100 every packet lost<br><br>

</dd>
<dt><big><a name="Player.world"></a>@property World <u>world</u>(World <u>world</u>);
</big></dt>
<dd>Teleports the player to another <u>world</u>.
<br><br>
<font color=red>BUGS:</font><br>
in Minecraft: Pocket Edition chunks are not unloaded, this means that the old-<u>world</u>'s chunks that
 		are not re-sent by the new <u>world</u> will be visible and usable by the client.<br><br>

</dd>
<dt><big><a name="Player.sendTip"></a>void <u>sendTip</u>(string <i>message</i>);
<br><a name="Player.tip"></a>alias <u>tip</u> = sendTip;
</big></dt>
<dd>Sends a <u>tip</u> <i>message</i> that will be displayed above the hotbar for two
 seconds before fading out.
<br><br>
<b>Example:</b><br>
<pre class="d_code">player.<u>sendTip</u>(<font color=red>"Hello there!"</font>);
@event move(PlayerMoveEvent event) {
   <font color=blue>with</font>(event.position)
      event.player.<u>sendTip</u>(<font color=red>"{0},{1},{2}"</font>, x.to!string, y.to!string, z.to!string);
}
</pre>
<br><br>

</dd>
<dt><big><a name="Player.title"></a>Title <u>title</u>(Title <u>title</u>);
</big></dt>
<dd>Sends a <u>title</u> message that will be displayed at the centre of the screen.
 The Title struct can be used to control the <u>title</u> message, the subtitle and
 the timing for the animations (fade in, stay and fade out).
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// fade in, display title and subtitle and fade out
</font>player.<u>title</u> = Title(<font color=red>"title"</font>, <font color=red>"subtitle"</font>);

<font color=green>// display a title for 3 seconds
</font>player.<u>title</u> = Title(Text.green ~ <font color=red>"green title"</font>, 60);

<font color=green>// display a subtitle for 10 seconds and fade out in 5 seconds
</font>player.<u>title</u> = Title(<font color=red>""</font>, <font color=red>"subtitle"</font>, 0, 200, 100);
</pre>
<br><br>

</dd>
<dt><big><a name="Player.hideTitle"></a>void <u>hideTitle</u>();
</big></dt>
<dd>Hides the title displayed with the title property without
 resetting it.<br><br>

</dd>
<dt><big><a name="Player.clearTitle"></a>void <u>clearTitle</u>();
</big></dt>
<dd>Removes the title displayed with the title property.<br><br>

</dd>
<dt><big><a name="Player.consumeTools"></a>@nogc @property @safe bool <u>consumeTools</u>();
</big></dt>
<dd>Boolean values indicating whether or not the player's tools should be consumed when used.<br><br>

</dd>
<dt><big><a name="Player.gamemode"></a>final pure nothrow @nogc @property @safe ubyte <u>gamemode</u>();
<br><a name="Player.survival"></a>final pure nothrow @nogc @property @safe bool <u>survival</u>();
<br><a name="Player.creative"></a>final pure nothrow @nogc @property @safe bool <u>creative</u>();
<br><a name="Player.adventure"></a>final pure nothrow @nogc @property @safe bool <u>adventure</u>();
<br><a name="Player.spectator"></a>final pure nothrow @nogc @property @safe bool <u>spectator</u>();
</big></dt>
<dd>Gets the player's <u>gamemode</u>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(player.<u>gamemode</u> == Gamemode.<u>creative</u>) {
   ...
}
<font color=blue>if</font>(player.<u>adventure</u>) {
   ...
}
</pre>
<br><br>

</dd>
<dt><big><a name="Player.gamemode.2"></a>final @property ubyte <u>gamemode</u>(ubyte <u>gamemode</u>);
<br><a name="Player.survival.2"></a>final @property bool <u>survival</u>(bool <i>set</i>);
<br><a name="Player.creative.2"></a>final @property bool <u>creative</u>(bool <i>set</i>);
<br><a name="Player.adventure.2"></a>final @property bool <u>adventure</u>(bool <i>set</i>);
<br><a name="Player.spectator.2"></a>final @property bool <u>spectator</u>(bool <i>set</i>);
</big></dt>
<dd>Sets the player's <u>gamemode</u>.<br><br>

</dd>
<dt><big><a name="Player.disconnect"></a>void <u>disconnect</u>(const Translation <i>reason</i> = Translation.DISCONNECT_CLOSED, string[] <i>args</i> = []);
<br>void <u>disconnect</u>(string <i>reason</i>);
<br><a name="Player.kick"></a>alias <u>kick</u> = disconnect;
</big></dt>
<dd>Disconnects the player from the server (from both
 the node and the hub).
 The <i>reason</i> can be a Translation.
<br><br>
<b>Params:</b><br>
<table><tr><td>Translation <i>reason</i></td>
<td><i>reason</i> of the disconnection</td></tr>
</table><br>

</dd>
<dt><big><a name="Player.transfer"></a>void <u>transfer</u>(inout Node <i>node</i>);
</big></dt>
<dd>Transfers the player in another <i>node</i>.
 The target <i>node</i> should be in server.nodes, otherwise
 the player will be disconnected by the hub with
 "End of Stream" message.
<br><br>
<b>Params:</b><br>
<table><tr><td>Node <i>node</i></td>
<td>the name of the <i>node</i> the player will be transferred to</td></tr>
</table><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> <i>node</i> = server.nodeWithName(<font color=red>"main_lobby"</font>);
<font color=blue>if</font>(<i>node</i> !<font color=blue>is</font> <font color=blue>null</font> &amp;&amp; <i>node</i>.accepts(player))
   player.<u>transfer</u>(<i>node</i>);
</pre>
<br><br>

 If the player should be transferred to another server using Pocket
 Edition's functionality the other <u>transfer</u> function should be used
 instead, using ip and port as parameters and not a <i>node</i> name.<br><br>

</dd>
<dt><big><a name="Player.transfer.2"></a>void <u>transfer</u>(string <i>ip</i>, ushort <i>port</i>);
</big></dt>
<dd>Transfers a player to given server and <i>port</i> if the client has
 the functionality to do so.
 Calling this method will not disconnect the player immediately.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>ip</i></td>
<td><i>ip</i> of the server, it could be either numeric of an hostname</td></tr>
<tr><td>ushort <i>port</i></td>
<td><i>port</i> of the server</td></tr>
</table><br>
<b>Throws:</b><br>
Exception if the client doesn't support the <u>transfer</u> functionality<br><br>

</dd>
<dt><big><a name="Player.container"></a>final @property @safe Container <u>container</u>();
</big></dt>
<dd>Returns the the current <u>container</u> the player is viewing.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(player.<u>container</u> !<font color=blue>is</font> <font color=blue>null</font>) {
   player.<u>container</u>.inventory = Items.BEETROOT;
}
</pre>
<br><br>

</dd>
<dt><big><a name="Player.spawn"></a>@property @trusted EntityPosition <u>spawn</u>(EntityPosition <u>spawn</u>);
<br>@property @safe EntityPosition <u>spawn</u>(BlockPosition <u>spawn</u>);
</big></dt>
<dd>Sets the player's <u>spawn</u> point.<br><br>

</dd>
<dt><big><a name="Player.motion"></a>@property @trusted EntityPosition <u>motion</u>(EntityPosition <u>motion</u>);
</big></dt>
<dd>Sets the <u>motion</u> and let the client do its physic actions.<br><br>

</dd>
<dt><big><a name="Player.hasCommand"></a>@safe bool <u>hasCommand</u>(string <i>cmd</i>);
</big></dt>
<dd>Checks if this player has a specific command.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(!player.<u>hasCommand</u>(<font color=red>"test"</font>)) {
   player.addCommand(<font color=red>"test"</font>, (arguments args){ player.sendMessage(<font color=red>"test"</font>); });
}
</pre>
<br><br>

</dd>
<dt><big><a name="Player.callCommand"></a>bool <u>callCommand</u>(string <i>cmd</i>, string <i>args</i>);
</big></dt>
<dd>Calls a command if the player has it.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the command has been called, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Player.callCommandOverload"></a>bool <u>callCommandOverload</u>(string <i>cmd</i>, size_t <i>overload</i>, Command.Arg[] <i>args</i>);
</big></dt>
<dd>Calls a command specifying which <i>overload</i>.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the command has been called, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="Player.registerCommand"></a>Command <u>registerCommand</u>(Command <i>_command</i>);
</big></dt>
<dd>Adds a new command using a command-container class.<br><br>

</dd>
<dt><big><a name="Player.unregisterCommand"></a>@safe void <u>unregisterCommand</u>(Command <i>command</i>);
<br>@safe void <u>unregisterCommand</u>(string <i>command</i>);
</big></dt>
<dd>Removes a <i>command</i> using the <i>command</i> class given in registerCommand.<br><br>

</dd>
<dt><big><a name="Player.commandMap"></a>@property @trusted Command[] <u>commandMap</u>();
</big></dt>
<dd><b>Returns:</b><br>
an unsorted list with the available commands<br><br>

</dd>
<dt><big><a name="Player.handleCompleteMessage"></a>protected void <u>handleCompleteMessage</u>(string <i>message</i>, bool <i>assumeCommand</i>);
</big></dt>
<dd>Completes the command args (or the command itself) if the arg type
 is an enum or a player (the ones in the world's list are sent), even
 if they are not spawned or visible to the player.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="isPlayer"></a>enum auto <u>isPlayer</u>(T);
</big></dt>
<dd>Checks whether or not the given symbol is of a connected player class.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the given symbol is or extends Player and not Puppet
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>isPlayer</u>!Player);
<font color=blue>assert</font>(!<u>isPlayer</u>!Puppet);
<font color=blue>assert</font>(<u>isPlayer</u>!PocketPlayerBase);
<font color=blue>assert</font>(<u>isPlayer</u>!(MinecraftPlayer!210));
<font color=blue>assert</font>(!<u>isPlayer</u>!(Projection!Puppet));
</pre>
<br><br>

</dd>
<dt><big><a name="isPlayerInstance"></a>@nogc @safe bool <u>isPlayerInstance</u>(Entity <i>entity</i>);
</big></dt>
<dd>Checks if the given <i>entity</i> is an instance of a connected player.
<br><br>
<b>Params:</b><br>
<table><tr><td>Entity <i>entity</i></td>
<td>an instance of an <i>entity</i></td></tr>
</table><br>
<b>Returns:</b><br>
<b>true</b> if the <i>entity</i> can be casted to Player and not to Puppet
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>isPlayerInstance</u>(player!<font color=red>"steve"</font>));
<font color=blue>assert</font>(!<u>isPlayerInstance</u>(<font color=blue>new</font> Puppet(player!<font color=red>"steve"</font>)));
</pre>
<br><br>

</dd>
<dt><big><a name="Puppet"></a>abstract class <u>Puppet</u>: <u>sel.player.player.Player</u>;
</big></dt>
<dd>Unconnected player for visualization.
 In the world is registered as an entity and it will
 not be found in the array of player obtained with
 world.online!Player nor in the count obtained with
 world.count!Player.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>//spawn a puppet 10 blocks over a player that follows it
</font><font color=blue>class</font> PuppetWorld : World {

   <font color=blue>private</font> <u>Puppet</u>[<font color=blue>uint</font>] puppets;

   <font color=blue>public</font> @event join(PlayerSpawnEvent event) {
      <font color=blue>this</font>.puppets[event.player.id] = <font color=blue>this</font>.spawn!<u>Puppet</u>(event.player.position, event.player.name, event.player.skin, event.player.uuid);
   }

   <font color=blue>public</font> @event left(PlayerDespawnEvent event) {
      <font color=blue>this</font>.despawn(<font color=blue>this</font>.puppets[event.player.id]);
      <font color=blue>this</font>.puppets.remove(event.player.id);
   }

   <font color=blue>public</font> @event move(PlayerMoveEvent event) {
      <font color=blue>this</font>.puppets[event.player.id].move(event.position, event.yaw, event.bodyYaw, event.pitch);
   }

}
</pre>
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Unticked puppets will reduce the CPU usage
</font><font color=blue>auto</font> ticked = <font color=blue>new</font> <u>Puppet</u>();
<font color=blue>auto</font> unticked = <font color=blue>new</font> Unticked!<u>Puppet</u>();
</pre>
<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
