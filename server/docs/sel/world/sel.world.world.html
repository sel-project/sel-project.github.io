<html><head>
        <!-- Generated by Ddoc from sel/world/world.d -->
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>sel.world.world</title>
        </head><body>
        <h1>sel.world.world</h1>
<br><br>
<dl><dt><big><a name="World"></a>class <u>World</u>: <u>sel.event.event.EventListener!(WorldEvent, EntityEvent, "entity", PlayerEvent, "player").EventListener</u>, <u>sel.lang.Messageable</u>;
</big></dt>
<dd>Basic world.<br><br>

<dl><dt><big><a name="World.name"></a>final pure nothrow @nogc @property @safe immutable(string) <u>name</u>();
</big></dt>
<dd>Gets the world's <u>name</u> used for identification and
 loggin purposes.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(!server.worldsWithName(world.<u>name</u>).canFind(world)) {
   log(world.<u>name</u>, <font color=red>" is not managed by the server"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.dimension"></a>final pure nothrow @nogc @property @safe Dimension <u>dimension</u>();
</big></dt>
<dd>Gets the world's <u>dimension</u> as a group of bytes.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(world.<u>dimension</u> == Dimension.nether) {
   log(<font color=red>"world is nether!"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.seed"></a>final pure nothrow @nogc @property @safe const(uint) <u>seed</u>();
</big></dt>
<dd>Gets the world's <u>seed</u> used for terrain and randomness
 generation.<br><br>

</dd>
<dt><big><a name="World.type"></a>final pure nothrow @nogc @property @safe const(string) <u>type</u>();
</big></dt>
<dd>Gets the world's <u>type</u> as a string.
 Valid types are "flat" and "default" for both Minecraft and
<br><br>
<b>Minecraft:</b><br>
Pocket Edition plus "largeBiomes", "amplified" and
 "customized" for Minecraft only.<br><br>

</dd>
<dt><big><a name="World.random"></a>final pure nothrow @nogc @property ref @safe Random <u>random</u>();
</big></dt>
<dd>Gets the world's <u>random</u> generator initialised with the
 world's seed.<br><br>

</dd>
<dt><big><a name="World.parent"></a>final pure nothrow @nogc @property @safe World <u>parent</u>();
</big></dt>
<dd>Gets the world's <u>parent</u> world.
<br><br>
<b>Returns:</b><br>
A world instance if the world has a <u>parent</u>, <b>null</b> otherwise
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(world.<u>parent</u> !<font color=blue>is</font> <font color=blue>null</font>) {
   <font color=blue>assert</font>(world.<u>parent</u>.canFind(world));
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.children"></a>final pure nothrow @nogc @property @safe World[] <u>children</u>();
</big></dt>
<dd>Gets the world's <u>children</u>.
<br><br>
<b>Returns:</b><br>
An array of worlds, empty if the world has no <u>children</u>
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(world.<u>children</u>.length) {
   log(world.name, <font color=red>" has "</font>, world.<u>children</u>.length, <font color=red>" child(ren)"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.hasChild"></a>final pure nothrow @nogc @safe bool <u>hasChild</u>(World <i>world</i>);
</big></dt>
<dd>Checks whether or not the given <i>world</i> is a child of this one.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(!overworld.<u>hasChild</u>(nether)) {
   overworld.addChild(nether);
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.addChild"></a>final T <u>addChild</u>(T : World = World, E...)(E <i>args</i>) if (__traits(compiles, new T(<i>args</i>)));
</big></dt>
<dd>Adds a child to the world.
 A child world is not managed (and ticked) by the server but
 by its parent. This means that this method should be used instead
 of server.addWorld.
<br><br>
<b>Returns:</b><br>
a new instance of the given world, constructed with the given parameters
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> overworld = server.addWorld!Overworld();
<font color=blue>auto</font> nether = overworld.<u>addChild</u>!Nether();
</pre>
<br><br>

</dd>
<dt><big><a name="World.removeChild"></a>final bool <u>removeChild</u>(World <i>world</i>);
</big></dt>
<dd>Removes a child.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the given <i>world</i> was a child, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="World.ticks"></a>final pure nothrow @nogc @property @safe tick_t <u>ticks</u>();
</big></dt>
<dd>Gets the number of this <u>ticks</u> occurred since the
 creation of the world.<br><br>

</dd>
<dt><big><a name="World.broadcast"></a>final void <u>broadcast</u>(E...)(E <i>args</i>);
</big></dt>
<dd>Broadcasts a message (raw or translatable) to every player in the world.<br><br>

</dd>
<dt><big><a name="World.time"></a>final pure nothrow @nogc @property @safe tick_t <u>time</u>();
</big></dt>
<dd>Gets the world's <u>time</u>.
 The returned value is always in range 0..24000, where
 0 is sunrise.
 The <u>time</u> doesn't change if the field daylight-cycle in the
 world's rules is set to <b>false</b>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(world.<u>time</u> &gt; Time.sunset) {
   world.<u>time</u> = Time.sunrise;
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.time.2"></a>final @property tick_t <u>time</u>(tick_t <u>time</u>);
</big></dt>
<dd>Sets the world's <u>time</u>.
 If the given value is not in the range 0..24000 the value
 will be the modulo of the division for 24000.
<br><br>
<b>Example:</b><br>
<pre class="d_code">world.<u>time</u> = 30000;
<font color=blue>assert</font>(world.<u>time</u> == Time.noon);
</pre>
<br><br>

</dd>
<dt><big><a name="World.downfall"></a>@nogc @property @safe bool <u>downfall</u>();
</big></dt>
<dd>Whether or not it's raining or snowing.<br><br>

</dd>
<dt><big><a name="World.downfall.2"></a>@property bool <u>downfall</u>(bool <u>downfall</u>);
</big></dt>
<dd>Toggles or untoggles downfalls.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(world.<u>downfall</u>) {
   world.<u>downfall</u> = <font color=blue>false</font>;
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.weather"></a>final pure nothrow @nogc @property @safe Weather <u>weather</u>();
</big></dt>
<dd>Gets the current <u>weather</u>.<br><br>

</dd>
<dt><big><a name="World.entities"></a>@property T[] <u>entities</u>(T = Entity, string condition = "")();
<br>@property Entity[] <u>entities</u>(string condition)();
</big></dt>
<dd>Gets the <u>entities</u> spawned in the world.<br><br>

</dd>
<dt><big><a name="World.players"></a>@property T[] <u>players</u>(T = Player, string condition = "")() if (isPlayer!T);
<br>@property Player[] <u>players</u>(string condition)();
</big></dt>
<dd>Gets a list of the <u>players</u> spawned in the world.<br><br>

</dd>
<dt><big><a name="World.spawn"></a>final T <u>spawn</u>(T : Entity, E...)(E <i>args</i>) if (!isPlayer!T);
</big></dt>
<dd>Spawns an entity.<br><br>

</dd>
<dt><big><a name="World.despawn"></a>final void <u>despawn</u>(T : Entity)(T <i>entity</i>) if (!isPlayer!T);
</big></dt>
<dd>Despawns an <i>entity</i>.<br><br>

</dd>
<dt><big><a name="World.drop"></a>final ItemEntity <u>drop</u>(Slot <i>slot</i>, EntityPosition <i>position</i>, EntityPosition <i>motion</i>);
<br>final ItemEntity <u>drop</u>(Slot <i>slot</i>, EntityPosition <i>position</i>);
<br>final void <u>drop</u>(Block <i>from</i>, BlockPosition <i>position</i>);
</big></dt>
<dd>Drops an item.<br><br>

</dd>
<dt><big><a name="World.strike"></a>final void <u>strike</u>(bool visual = false)(EntityPosition <i>position</i>);
<br>final void <u>strike</u>(Entity <i>entity</i>);
</big></dt>
<dd>Stikes a lightning.<br><br>

</dd>
<dt><big><a name="World.entity"></a>final @safe Entity <u>entity</u>(uint <i>eid</i>);
</big></dt>
<dd>Gets an <u>entity</u> from an id.<br><br>

</dd>
<dt><big><a name="World.player"></a>final @safe Player <u>player</u>(uint <i>eid</i>);
</big></dt>
<dd>Gets a <u>player</u> from an id.<br><br>

</dd>
<dt><big><a name="World.chunks"></a>final pure nothrow @nogc @property @safe Chunk[int][int] <u>chunks</u>();
</big></dt>
<dd>Gets an associative array with every chunk loaded in
 the world.<br><br>

</dd>
<dt><big><a name="World.loadedChunks"></a>final pure @nogc @property @safe size_t <u>loadedChunks</u>(bool children = false)();
</big></dt>
<dd>Gets the number of loaded chunks in the world and
 its children.<br><br>

</dd>
<dt><big><a name="World.opIndex"></a>final @safe Chunk <u>opIndex</u>(int <i>x</i>, int <i>z</i>);
<br>final @safe Chunk <u>opIndex</u>(ChunkPosition <i>position</i>);
</big></dt>
<dd>Gets a chunk.
<br><br>
<b>Returns:</b><br>
the chunk at given <i>position</i> or <b>null</b> if the chunk doesn't exist<br><br>

</dd>
<dt><big><a name="World.opBinaryRight"></a>final @safe Chunk* <u>opBinaryRight</u>(string op : "in")(ChunkPosition <i>position</i>);
</big></dt>
<dd>Gets a pointer to the chunk at the given <i>position</i>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(ChunkPosition(100, 100) <font color=blue>in</font> world) {
   log(<font color=red>"world doesn't have the chunk at 100, 100"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.opIndexAssign"></a>final @safe Chunk <u>opIndexAssign</u>(Chunk <i>chunk</i>);
</big></dt>
<dd>Sets a <i>chunk</i>.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>auto</font> <i>chunk</i> = <font color=blue>new</font> Chunk(world, ChunkPosition(1, 2));
world[] = <i>chunk</i>;
<font color=blue>assert</font>(world[1, 2] == <i>chunk</i>);
</pre>
<br><br>

</dd>
<dt><big><a name="World.generate"></a>Chunk <u>generate</u>(ChunkPosition <i>position</i>);
<br>Chunk <u>generate</u>(int <i>x</i>, int <i>z</i>);
</big></dt>
<dd>Generates and sets a chunk.
<br><br>
<b>Returns:</b><br>
the generated chunk<br><br>

</dd>
<dt><big><a name="World.unload"></a>bool <u>unload</u>(ChunkPosition <i>position</i>);
</big></dt>
<dd>Unloads and removes a chunk.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the chunk was removed, <b>false</b> otherwise<br><br>

</dd>
<dt><big><a name="World.opIndex.2"></a>Block <u>opIndex</u>(BlockPosition <i>position</i>);
<br>Block <u>opIndex</u>(int <i>x</i>, uint <i>y</i>, int <i>z</i>);
</big></dt>
<dd>Gets a block.
<br><br>
<b>Returns:</b><br>
an instance of block, which is never <b>null</b>
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=blue>if</font>(world[0, 0, 0] != Blocks.BEDROCK) {
   log(<font color=red>"0,0,0 is not bedrock!"</font>);
}
</pre>
<br><br>

</dd>
<dt><big><a name="World.tileAt"></a>@safe T <u>tileAt</u>(T = Tile)(int <i>x</i>, uint <i>y</i>, int <i>z</i>) if (is(T == class) || is(T == interface));
<br>@safe T <u>tileAt</u>(T = Tile)(BlockPosition <i>position</i>);
</big></dt>
<dd>Gets a tile.<br><br>

</dd>
<dt><big><a name="World.opIndexAssign.2"></a>Block* <u>opIndexAssign</u>(bool sendUpdates = true, T)(T <i>block</i>, BlockPosition <i>position</i>) if (is(T == block_t) || is(T == block_t[]) || is(T == Block*));
<br>Block* <u>opIndexAssign</u>(T)(T <i>block</i>, int <i>x</i>, uint <i>y</i>, int <i>z</i>) if (is(T == block_t) || is(T == block_t[]) || is(T == Block*));
</big></dt>
<dd>Sets a <i>block</i>.
<br><br>
<b>Example:</b><br>
<pre class="d_code">world[0, 55, 12] = Blocks.grass;
world[12, 55, 789] = Blocks.chest; <font color=green>// not a tile!
</font></pre>
<br><br>

</dd>
<dt><big><a name="World.opIndexAssign.3"></a>void <u>opIndexAssign</u>(T)(T <i>tile</i>, BlockPosition <i>position</i>) if (is(T : Tile) &amp;&amp; is(T : Block));
<br>void <u>opIndexAssign</u>(T)(T <i>tile</i>, int <i>x</i>, uint <i>y</i>, int <i>z</i>) if (is(T : Tile) &amp;&amp; is(T : Block));
</big></dt>
<dd>Sets a <i>tile</i>.<br><br>

</dd>
<dt><big><a name="World.opIndexAssign.4"></a>final void <u>opIndexAssign</u>(block_t <i>b</i>, Slice <i>x</i>, Slice <i>y</i>, Slice <i>z</i>);
<br>final void <u>opIndexAssign</u>(block_t <i>b</i>, int <i>x</i>, Slice <i>y</i>, Slice <i>z</i>);
<br>final void <u>opIndexAssign</u>(block_t <i>b</i>, Slice <i>x</i>, uint <i>y</i>, Slice <i>z</i>);
<br>final void <u>opIndexAssign</u>(block_t <i>b</i>, Slice <i>x</i>, Slice <i>y</i>, int <i>z</i>);
<br>final void <u>opIndexAssign</u>(block_t <i>b</i>, int <i>x</i>, uint <i>y</i>, Slice <i>z</i>);
<br>final void <u>opIndexAssign</u>(block_t <i>b</i>, int <i>x</i>, Slice <i>y</i>, int <i>z</i>);
<br>final void <u>opIndexAssign</u>(block_t <i>b</i>, Slice <i>x</i>, uint <i>y</i>, int <i>z</i>);
</big></dt>
<dd>Sets the same block in a rectangualar area.
 This method is optimised for building as it uses a cached pointer
 instead of getting it every time and it doesn't call any block
 update.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// sets a chunk to stone
</font>world[0..16, 0..$, 0..16] = Blocks.stone;

<font color=green>// sets an area to air
</font>world[0..16, 64..128, 0..16] = Blocks.air;

<font color=green>// sets a 1-block-high layer only
</font>world[0..16, 64, 0..16] = Blocks.beetroot0;
</pre>
<br><br>

</dd>
<dt><big><a name="World.updateTile"></a>final void <u>updateTile</u>(Tile <i>tile</i>, BlockPosition <i>position</i>);
</big></dt>
<dd>function called by a <i>tile</i> when its data is updated<br><br>

</dd>
<dt><big><a name="World.scheduleBlockUpdate"></a>@safe void <u>scheduleBlockUpdate</u>(Block <i>block</i>, uint <i>time</i>);
</big></dt>
<dd>schedules a <i>block</i> update<br><br>

</dd>
<dt><big><a name="World.registerCommand"></a>void <u>registerCommand</u>(alias func)(void delegate(Parameters!func) <i>del</i>, string <i>command</i>, string <i>description</i>, string[] <i>aliases</i>, string[] <i>params</i>, bool <i>op</i>, bool <i>hidden</i>);
</big></dt>
<dd>Registers a <i>command</i>.<br><br>

</dd>
<dt><big><a name="World.unregisterCommand"></a>void <u>unregisterCommand</u>(string <i>command</i>);
</big></dt>
<dd>Unregisters a <i>command</i>.<br><br>

</dd>
<dt><big><a name="World.addTask"></a>@safe size_t <u>addTask</u>(E...)(void delegate(E) <i>task</i>, size_t <i>interval</i>, size_t <i>repeat</i> = size_t.max) if (areValidTaskArgs!E);
<br><a name="World.schedule"></a>alias <u>schedule</u> = addTask(E...)(void delegate(E) task, size_t interval, size_t repeat = size_t.max) if (areValidTaskArgs!E);
</big></dt>
<dd>Registers a <i>task</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>void delegate(E) <i>task</i></td>
<td>a delegate of a function that will be called every <i>interval</i></td></tr>
<tr><td>size_t <i>interval</i></td>
<td>number of ticks indicating between the calls</td></tr>
<tr><td>size_t <i>repeat</i></td>
<td>number of times to <i>repeat</i> the <i>task</i></td></tr>
</table><br>
<b>Returns:</b><br>
the new <i>task</i> id that can be used to remove the <i>task</i><br><br>

</dd>
<dt><big><a name="World.delay"></a>@safe size_t <u>delay</u>(E...)(void delegate(E) <i>task</i>, size_t <i>timeout</i>) if (areValidTaskArgs!E);
</big></dt>
<dd>Executes a <i>task</i> one time after the given ticks.<br><br>

</dd>
<dt><big><a name="World.removeTask"></a>@safe void <u>removeTask</u>(E...)(void delegate(E) <i>task</i>) if (areValidTaskArgs!E);
<br>@safe void <u>removeTask</u>(size_t <i>tid</i>);
</big></dt>
<dd>Removes a <i>task</i> using the <i>task</i>'s delegate or the id returned
 by the addTask function.<br><br>

</dd>
<dt><big><a name="World.growTree"></a>static void <u>growTree</u>(World <i>world</i>, BlockPosition <i>position</i>, ushort[] <i>trunk</i> = Blocks.oakWood, ushort <i>leaves</i> = Blocks.oakLeavesDecay);
</big></dt>
<dd>Grows a tree in the given <i>world</i>.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. </small>
        </body></html>
